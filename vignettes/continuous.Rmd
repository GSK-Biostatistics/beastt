---
title: "Continuous Case With Assumed Known SD"
package: beastt
output: 
  rmarkdown::html_vignette:
    toc: true
    code_folding: show
vignette: >
  %\VignetteIndexEntry{Continuous Case}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
  editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(beastt)
```

For this example we are going to walk through how to use Bayesian dynamic borrowing with propensity score matching. For this example we are just going to use the data from the package. The data we have has a response variable and then four covariates to match on. Covariate 1, is a normally distributed with a mean around 55 and 50 for the internal and external data respectively. All other covariates are binary responses with varying response rate. 

```{r class.source = 'fold-hide'}
library(tibble)
library(distributional)
library(ggplot2)
set.seed(1234)

summary(int_norm_df)
summary(ex_norm_df)
sd_external_control <- 5
sd_internal_control <- 3
n_external <- nrow(ex_norm_df)
```

With the data we can calculate the propensity scores for the internal and external controls using the `calc_prop_scr` function. This creates a propensity score object which we can use for calculating power priors in the next step.

```{r}
ps_model <- ~ cov1 + cov2 + cov3 + cov4
ps_obj <- calc_prop_scr(internal_df = int_norm_df, 
                        external_df = ex_norm_df, 
                        id_col = subjid,
                        model = ps_model)

ps_obj
```

In order to check the suitability of the external data we can create a variety of diagnostic plots. The first plot we might want is a histogram. To get that we are going to use the `prop_scr_hist` function. This function takes in the propensity score object made in the previous step. Then we can optionally supply the variable we want to look at, either the propensity score or the inverse probability weight. By default it will plot the propensity scores. Additionally, we can look at the densities rather than histograms by using the `prop_scr_dens` function. When looking at the inverse probability weights with either the histogram or the density functions, it is important to note only the external data will be shown because value of the internal data will just be 1.

```{r}
prop_scr_hist(ps_obj)
prop_scr_dens(ps_obj, variable = "ipw")
```

The final plot we might want to look at is a love plot to visualize the standard mean differences of the covariates between the internal and external data. To do this we are just going to use the 'prop_scr_love' function. Like the previous function the only required parameter for this function is the propensity score object, but we can also provide a location for a reference line.

```{r}
prop_scr_love(ps_obj, reference_line = 0.4)
```

Now that we are happy with our propensity score we can use it to calculate a power prior. To calculate the power prior we need to supply:

-   weighted object, the propensity score we created above

-   response variable, in this case y

-   prior, in the form of a distributional object

-   external control sd

The prior and the external control SD are optional. If no prior is provided, a improper initial prior will be used. If there is no external control sd or prior then a t distirbution power prior will be created. 

Finally, once we have a power prior we might want to plot it. To do that we can just the `plot_dist` function.

```{r}
pwr_prior <- calc_power_prior_norm(
  ps_obj, response = y, 
  prior = dist_normal(92, 100), 
  external_control_sd = sd_external_control)
plot_dist(pwr_prior)
```


Now that we have a power prior we can calculate the posterior using the `calc_post_norm` function 
```{r}
post <- calc_post_norm(ps_obj,
                       response = y,
                       internal_control_sd = sd_internal_control, 
                       prior= pwr_prior)
plot_dist(post)
```

If you want to add a vague component to the distirbution you just make a mixture distribution and pass it to `calc_post_norm`

```{r}
prior_param <- parameters(pwr_prior)
mixed_prior <- dist_mixture(
  pwr_prior, 
  dist_normal(prior_param$mu, sqrt(prior_param$sigma^2*n_external)),
  weights =  c(.5, .5)
)

post <- calc_post_norm(ps_obj,
                       response = y,
                       internal_control_sd = sd_internal_control, 
                       prior= mixed_prior)
plot_dist(post)
```


